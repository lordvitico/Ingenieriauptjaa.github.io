<!DOCTYPE html>
<html>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <head>
        <title>Nuestro Blog</title>
        <link rel="stylesheet" href="CSS/1html.css">
        <link rel="stylesheet" href="CSS/Encavezado.css">
        <link rel="stylesheet" href="CSS/leer1.css">
        <link rel="stylesheet" href="CSS/leer2.css">
        <link rel="stylesheet" href="CSS/leer3.css">
        <link rel="stylesheet" href="CSS/leer4.css">
        <link rel="stylesheet" href="CSS/leer5.css">
        <link rel="stylesheet" href="CSS/leer6.css">
        <link rel="stylesheet" href="CSS/leer7.css">
        <link rel="stylesheet" href="CSS/leer8.css">
        <link rel="stylesheet" href="CSS/leer9.css">
        <link rel="stylesheet" href="CSS/leer10.css">
        <link rel="stylesheet" href="CSS/leer11.css">
        <link rel="stylesheet" href="CSS/leer12.css">
        <link rel="stylesheet" href="CSS/art1.css">
        <link rel="stylesheet" href="CSS/art2.css">
        <link rel="stylesheet" href="CSS/art3.css">
        <link rel="stylesheet" href="CSS/art4.css">
        <link rel="stylesheet" href="CSS/art5.css">
        <link rel="stylesheet" href="CSS/art6.css">
        <link rel="stylesheet" href="CSS/art7.css">
        <link rel="stylesheet" href="CSS/art8.css">
        <link rel="stylesheet" href="CSS/art9.css">
        <link rel="stylesheet" href="CSS/art10.css">
        <link rel="stylesheet" href="CSS/art11.css">
        <link rel="stylesheet" href="CSS/art12.css">
        <link rel="stylesheet" href="CSS/imagenes.css">
    </head>
    <body>
        <header>
            <div class="tornado">
                <img src='Images/logo.png' alt='uptjaa' class='louptj'>
                <h1>Desarrollo del software</h1>
                <p><b>Ingenier√≠a del software, Ing. Nubia Villarroel<br>
                Alumnos: Victor Correa (31609356), Simon Rebanales (32204510), Fabian Perdomo (32622776)<br>
                Seccion: 7</b>
                </p>
            </div>
        </header>
        <article id="est">
            <h2>Vision General del proceso del software</h2>
            <div id="txt">
                <p>El desarrollo de software es un proceso estructurado que permite la 
                    creacion de aplicaciones y sistemas... informaticos capaces de resolver problemas 
                    o satisfacer necesidades especificas. Este proceso se compone de varias etapas 
                    fundamentales que garantizan calidad, funcionalidad y adaptabilidad del producto 
                    final, Es un conjunto ordenado de actividades que permiten crear, modificar y 
                    mantener aplicaciones y sistemas inform√°ticos. Este proceso no es lineal ni r√≠gido: puede ser iterativo, incremental o adaptativo, dependiendo del 
                    enfoque metodol√≥gico (como cascada, √°gil, DevOps, etc.). Su objetivo es convertir una necesidad o idea en una soluci√≥n 
                    tecnol√≥gica funcional, eficiente y escalable.<br>
                    Las etapas serian:<br>
                    1. üìã Recolecci√≥n y an√°lisis de requisitos
                    - Se identifica qu√© necesita el cliente o usuario final.
                    - Incluye entrevistas, cuestionarios, an√°lisis de mercado, 
                    modelos de casos de uso.
                    - Se documentan los requisitos funcionales y no funcionales, 
                    como rendimiento, seguridad y usabilidad.<br>
                    <br>
                    2. üß† Planificaci√≥n
                    - Se establece el alcance del proyecto, recursos humanos 
                    y t√©cnicos, cronograma y presupuesto.
                    - Se define el ciclo de vida del software y se escoge la
                    metodolog√≠a adecuada (√°gil, Scrum, cascada, etc.).<br>
                    <br>
                    3. üèóÔ∏è Dise√±o del sistema
                    - Se estructura la arquitectura del software: m√≥dulos, 
                    componentes, interfaces y bases de datos.
                    - Se utilizan diagramas UML, esquemas ER, wireframes, 
                    mockups y patrones de dise√±o.<br>
                    <br>
                    4. üíª Desarrollo o codificaci√≥n
                    - Es la fase de implementaci√≥n: los desarrolladores 
                    escriben el c√≥digo en distintos lenguajes (Java, Python, 
                    C#, JavaScript...).
                    - Se utilizan entornos de desarrollo (IDE), control de 
                    versiones (como Git), y pruebas unitarias desde el inicio.<br>
                    <br>
                    5. üß™ Pruebas
                    - Se busca detectar errores (bugs), inconsistencias y 
                    vulnerabilidades.
                    - Incluye pruebas unitarias, de integraci√≥n, de sistema, 
                    funcionales, de rendimiento, de seguridad, y de aceptaci√≥n por el usuario.
                    - Herramientas comunes: Selenium, JUnit, Postman, 
                    entre otros.<br>
                    <br>
                    6. üöÄ Implementaci√≥n / Despliegue
                    - El software se instala en el entorno de producci√≥n.
                    - Puede hacerse en fases (lanzamientos parciales), o
                    mediante m√©todos como canary releases o blue-green deployments.
                    - En sistemas web, implica configurar servidores, bases de datos,  
                    balanceadores, y asegurar disponibilidad.<br>
                    <br>
                    7. üîß Mantenimiento y evoluci√≥n
                    - Se corrigen errores post-lanzamiento (mantenimiento correctivo).
                    - Se agregan nuevas funciones o mejoras
                    (mantenimiento perfectivo/adaptativo).
                    - Se eval√∫a el desempe√±o del software en tiempo real 
                    y se optimiza.
                </p>
            </div>
            <button id="btn">Leer Mas</button>
        </article>
        <script src="JavaScript/see1.js"></script>
        <article id="esx">
            <h2> El Papel del Usuario dentro del Proceso de Desarrollo de Software </h2>
            <div id="txd">
                <p>Es fundamental en el proceso de desarrollo de software, ya que es la persona que 
                    finalmente utilizar√° el producto. Su participaci√≥n 
                    activa garantiza que el software desarrollado sea relevante, √∫til y f√°cil de usar...<br>
                    <br>
                    1. Definici√≥n de Requisitos y Planificaci√≥n<br>
                    <br>
                    El usuario es la fuente principal de informaci√≥n sobre lo que el software necesita hacer. 
                    Sin su aportaci√≥n, los desarrolladores podr√≠an crear un producto que no resuelva los problemas 
                    reales o que no satisfaga las expectativas del mercado.<br>
                    <br>
                    -Identificaci√≥n de necesidades: Los usuarios proporcionan informaci√≥n vital sobre sus objetivos, 
                    flujos de trabajo y los desaf√≠os que enfrentan. Esta informaci√≥n se utiliza para definir las historias 
                    de usuario, que describen lo que un usuario necesita hacer, por qu√© y qu√© valor esperan obtener.
                    <br>
                    -Priorizaci√≥n de caracter√≠sticas: El usuario ayuda a determinar qu√© funcionalidades son m√°s importantes 
                    y deben desarrollarse primero, asegurando que el producto final aporte valor real desde las primeras 
                    etapas.<br>
                    <br>
                    2. Dise√±o y Prototipado<br>
                    <br>
                    En esta fase, la colaboraci√≥n del usuario es esencial para crear una experiencia de usuario (UX) 
                    intuitiva y eficiente.<br>
                    <br>
                    -Dise√±o centrado en el usuario: El desarrollo de software debe evitar un dise√±o autorreferencial, 
                    basado √∫nicamente en las preferencias de los desarrolladores. La investigaci√≥n de usuarios, a 
                    trav√©s de encuestas, entrevistas y observaci√≥n, permite crear interfaces y productos centrados 
                    en las necesidades reales del usuario.<br>
                    <br>
                    -Validaci√≥n de prototipos: Los usuarios interact√∫an con prototipos iniciales para proporcionar 
                    comentarios sobre la usabilidad y la coherencia del dise√±o. Esto ayuda a identificar obst√°culos y 
                    dificultades de interacci√≥n antes de que se invierta tiempo y recursos en el desarrollo completo.<br>
                    <br>
                    3. Pruebas y Retroalimentaci√≥n<br>
                    <br>
                    La participaci√≥n del usuario en las pruebas es crucial para detectar errores y garantizar que el 
                    soft ware funcione como se espera<br>
                    <br>
                    -Pruebas de usabilidad: Se realizan para observar c√≥mo los usuarios interact√∫an con el software y 
                    recopilar retroalimentaci√≥n en tiempo real. Esto permite realizar ajustes y mejoras en funci√≥n de los 
                    datos obtenidos.<br>
                    <br>
                    -Pruebas de aceptaci√≥n: Los usuarios finales verifican si el software cumple con los requisitos 
                    definidos inicialmente. Su aprobaci√≥n es necesaria para avanzar a la fase de implementaci√≥n.<br>
                    <br>
                    4. Mantenimiento y Evoluci√≥n Continua<br>
                    <br>
                    El rol del usuario no termina con el lanzamiento del software. Su participaci√≥n continua es vital 
                    para el √©xito a largo plazo del producto.<br>
                    <br>
                    -Retroalimentaci√≥n constante: Los usuarios proporcionan informaci√≥n sobre errores, problemas de 
                    usabilidad y nuevas necesidades.<br>
                    <br>
                    -Mejora continua: El software evoluciona en funci√≥n de la retroalimentaci√≥n del usuario y las 
                    demandas del mercado, garantizando que el producto siga siendo relevante y √∫til.<br>
                </p>
            </div>
            <button id="bt">Leer Mas</button>
        </article>
        <script src="JavaScript/see2.js"></script>
        <article id="esp">
            <h2>Responsabilidad Etica y profesional en Ingenieria del Software:</h2>
            <div id="txp">
                <p>La responsabilidad √©tica y profesional en la ingenier√≠a de software es un pilar 
                fundamental en la creaci√≥n de tecnolog√≠a que impacta la vida de las personas y 
                la sociedad en su conjunto. Va m√°s all√° de simplemente escribir c√≥digo funcional; 
                implica considerar las implicaciones morales, sociales y de seguridad de los sistemas 
                que se desarrollan...<br>
                <br>
                Aqu√≠ se desglosan los aspectos clave de esta responsabilidad:<br>
                1. Inter√©s P√∫blico y Bienestar Humano<br>
                El principio fundamental es que los ingenieros de software deben actuar de manera 
                consistente con el inter√©s p√∫blico y el bienestar humano.<br>
                Esto significa:<br>
                -Minimizar da√±os: Evitar que el software cause da√±o a individuos o a la sociedad. 
                Esto incluye no desarrollar software que pueda ser utilizado para fines maliciosos, 
                como vigilancia excesiva, manipulaci√≥n de informaci√≥n o ataques cibern√©ticos.<br>
                -Promover los derechos humanos: Asegurarse de que el software respete los derechos 
                fundamentales de las personas, incluyendo la privacidad, la autonom√≠a y la no 
                discriminaci√≥n.<br>
                -Considerar a los menos favorecidos: Al enfrentar conflictos de intereses entre 
                diferentes grupos de usuarios, dar prioridad a las necesidades de los menos favorecidos.
                2. Calidad del Producto y Est√°ndares Profesionales<br>
                Los ingenieros de software tienen la responsabilidad de asegurar que sus productos 
                y modificaciones cumplen con los m√°s altos est√°ndares profesionales posibles.<br>
                Esto implica:<br>
                -Calidad, costo y cronograma: Esforzarse por lograr alta calidad, un costo aceptable 
                y un cronograma razonable, asegurando que los aspectos significativos sean claros y 
                aceptados por el cliente y el empleador.<br>
                -Pruebas exhaustivas: Garantizar pruebas adecuadas, depuraci√≥n y revisiones del 
                software y documentos relacionados para minimizar errores y vulnerabilidades.<br>
                -Documentaci√≥n clara: Mantener una documentaci√≥n adecuada, incluyendo 
                problemas significativos descubiertos y las soluciones adoptadas.<br>
                -Seguridad por dise√±o: Integrar pr√°cticas de seguridad desde el inicio del 
                ciclo de desarrollo del software (SDLC) para proteger los datos y la privacidad 
                del usuario.<br>
                3. Juicio Profesional e Integridad<br>
                Mantener la integridad e independencia en el juicio profesional es crucial. Esto 
                significa:<br>
                -Moderaci√≥n del juicio t√©cnico: Temperar todo juicio t√©cnico por la necesidad de
                 apoyar y mantener los valores humanos.<br>
                -Honestidad y veracidad: Ser justo y veraz en todas las afirmaciones, especialmente 
                las p√∫blicas, relativas al software, sus m√©todos y herramientas.<br>
                -Evitar conflictos de inter√©s: Notificar a todas las partes involucradas sobre 
                cualquier conflicto de intereses que no pueda ser razonablemente evitado.<br>
                -No participar en pr√°cticas enga√±osas: Abstenerse de pr√°cticas financieras 
                enga√±osas como soborno o doble facturaci√≥n.<br>
                4. Administraci√≥n y Liderazgo √âtico<br>
                Los ingenieros de software que ocupan roles de gerencia o liderazgo tienen 
                la responsabilidad adicional de promover y suscribirse a un enfoque √©tico en 
                la administraci√≥n del desarrollo y mantenimiento de software.<br>
                Esto incluye:<br>
                -Fomentar un ambiente √©tico: Ayudar a desarrollar un ambiente organizacional 
                favorable para actuar √©ticamente.<br>
                -Proteger la confidencialidad: Asegurar que los ingenieros conozcan las pol√≠ticas 
                y procedimientos del empleador para proteger informaci√≥n confidencial.<br>
                -No pedir actos anti√©ticos: Nunca pedir a un ingeniero de software que haga algo 
                en desacuerdo con el c√≥digo de √©tica.<br>
                5. La Profesi√≥n y los Colegas<br>
                Los ingenieros de software deben incrementar la integridad y reputaci√≥n de la 
                profesi√≥n consistentemente con el inter√©s social.<br>
                Esto implica:<br>
                -Apoyo a colegas: Apoyar y ser justo con los colegas, motiv√°ndolos a seguir el 
                c√≥digo de √©tica y ayud√°ndolos en su desarrollo profesional.<br>
                -Reconocimiento del trabajo: Reconocer completamente el trabajo de otros y 
                abstenerse de atribuirse m√©ritos indebidos.<br>
                -Revisi√≥n objetiva: Revisar el trabajo de otros de forma objetiva, sincera y 
                propiamente documentada.<br>
                6. Consideraciones √âticas Espec√≠ficas en la Era de la IA y el Big Data<br>
                El avance de la inteligencia artificial (IA) y el uso masivo de datos (Big Data) 
                han introducido nuevas y complejas responsabilidades √©ticas:<br>
                -Sesgos algor√≠tmicos: Los sistemas de IA aprenden de datos hist√≥ricos. Si estos 
                datos contienen sesgos, la IA puede perpetuar e incluso amplificar la discriminaci√≥n. 
                Los ingenieros tienen la responsabilidad de identificar, mitigar y corregir estos 
                sesgos en los conjuntos de datos y algoritmos.<br>
                -Transparencia y explicabilidad: La opacidad de las decisiones de la IA 
                ("cajas negras") plantea desaf√≠os. Se debe buscar la transparencia y la 
                interpretabilidad de los sistemas para que los usuarios puedan entender c√≥mo se 
                llega a ciertas conclusiones.<br>
                -Privacidad y protecci√≥n de datos: La IA depende en gran medida de datos personales 
                y sensibles. Proteger la privacidad del usuario y la confidencialidad de los datos 
                es imperativo, implementando medidas robustas de seguridad y cumpliendo con las 
                regulaciones de protecci√≥n de datos (como GDPR).<br>
                -Responsabilidad: Establecer l√≠neas claras de responsabilidad cuando los sistemas 
                de IA toman decisiones o causan da√±os es complejo. Los desarrolladores deben ser 
                conscientes de estos riesgos y tomar medidas para asegurar la rendici√≥n de cuentas.<br>
                -Impacto social y cultural: Evaluar el impacto del software en la sociedad, 
                incluyendo sus efectos en el empleo, la equidad social y la diversidad cultural.</p>
            </div>
            <button id="btp">Leer Mas</button>
        </article>
        <script src="JavaScript/see3.js"></script>
        <article id="esl">
            <h2>Ciclo de Vida del Software:</h2>
            <div id="txl">
                <p>El ciclo de vida del software (SDLC) es un marco de trabajo que define las fases o 
                    etapas por las que pasa un proyecto de software, desde su concepci√≥n inicial hasta 
                    su retiro. Su prop√≥sito es establecer un enfoque estructurado para el dise√±o, 
                    desarrollo, prueba y mantenimiento de software, asegurando que se cumplan los 
                    requisitos del usuario y se entregue un producto de alta calidad de manera eficiente.<br>
                    <br>
                    Fases Comunes del Ciclo de Vida del Software:<br>
                    Aunque existen varios modelos de SDLC, la mayor√≠a comparten un conjunto de fases 
                    fundamentales:<br>
                    <br>
                    1. Planificaci√≥n y An√°lisis de Requisitos<br>
                    Esta es la fase inicial y m√°s cr√≠tica. Los equipos de desarrollo se re√∫nen con los 
                    clientes y usuarios finales para comprender a fondo sus necesidades, expectativas y 
                    los objetivos del sistema. Se definen las funcionalidades deseadas, las restricciones 
                    (presupuesto, tiempo, recursos) y los criterios de rendimiento.<br>
                    <br>
                    Actividades clave: Recopilaci√≥n de requisitos (entrevistas, encuestas, talleres), 
                    an√°lisis de viabilidad, definici√≥n del alcance del proyecto, identificaci√≥n de 
                    riesgos y elaboraci√≥n de un plan de proyecto detallado.<br>
                    <br>
                    Resultados: Documento de requisitos del software (SRS), plan del proyecto.<br>
                    <br>
                    2.Dise√±o:<br>
                    En esta fase, los requisitos definidos se transforman en un dise√±o arquitect√≥nico 
                    ara el sistema. Se especifica c√≥mo se construir√° el software, incluyendo la 
                    estructura general, los m√≥dulos, las interfaces, las bases de datos y la interacci√≥n 
                    entre los componentes. Tambi√©n se considera el dise√±o de la interfaz de usuario 
                    (UI) y la experiencia del usuario (UX).<br>
                    <br>
                    Actividades clave: Dise√±o de la arquitectura del sistema, dise√±o de 
                    la base de datos, dise√±o de la interfaz de usuario, dise√±o de la l√≥gica 
                    de los m√≥dulos y creaci√≥n de diagramas (UML, diagramas de flujo).<br>
                    <br>
                    Resultados: Documento de dise√±o de software (SDD), prototipos de interfaz de usuario.<br>
                    <br>
                    3. Implementaci√≥n/Desarrollo<br>
                    Aqu√≠ es donde el c√≥digo se escribe bas√°ndose en las especificaciones de dise√±o. 
                    Los programadores desarrollan los diferentes m√≥dulos y componentes del software 
                    utilizando los lenguajes de programaci√≥n y las herramientas seleccionadas.<br>
                    <br>
                    Actividades clave: Codificaci√≥n, construcci√≥n de la base de datos, integraci√≥n de 
                    m√≥dulos y desarrollo de pruebas unitarias.<br>
                    <br>
                    Resultados: C√≥digo fuente funcional, m√≥dulos de software.<br>
                    <br>
                    4. Pruebas<br>
                    Una vez que el software ha sido desarrollado, se somete a pruebas rigurosas para 
                    identificar y corregir errores (bugs), defectos y asegurar que el sistema cumple 
                    con los requisitos definidos en la fase de an√°lisis. Esta fase puede incluir 
                    diferentes tipos de pruebas:<br>
                    <br>
                    Pruebas unitarias: Prueban componentes individuales del software.<br>
                    <br>
                    Pruebas de integraci√≥n: Verifican la interacci√≥n entre los m√≥dulos.<br>
                    <br>
                    Pruebas de sistema: Prueban el sistema completo para asegurar que funciona 
                    como un todo.<br>
                    <br>
                    Pruebas de aceptaci√≥n del usuario (UAT): Los usuarios finales 
                    validan que el software satisface sus necesidades.<br>
                    <br>
                    Actividades clave: Ejecuci√≥n de casos de prueba, reporte y seguimiento de 
                    defectos, regresi√≥n de pruebas.<br>
                    <br>
                    Resultados: Informes de pruebas, software probado y listo para su implementaci√≥n.<br>
                    <br>
                    5. Despliegue/Implementaci√≥n<br>
                    En esta fase, el software se instala y configura en el entorno de producci√≥n, 
                    haci√©ndolo accesible para los usuarios finales. Esto puede implicar la migraci√≥n 
                    de datos, la capacitaci√≥n de usuarios y la configuraci√≥n de la infraestructura 
                    necesaria.<br>
                    <br>
                    Actividades clave: Instalaci√≥n del software, configuraci√≥n del entorno, 
                    migraci√≥n de datos, capacitaci√≥n de usuarios, lanzamiento del producto.<br>
                    <br>
                    Resultados: Software operativo en el entorno de producci√≥n.<br>
                    <br>
                    6. Mantenimiento<br>
                    El ciclo de vida del software no termina con su lanzamiento. 
                    La fase de mantenimiento implica el soporte continuo del sistema, 
                    la correcci√≥n de errores que no se detectaron en las pruebas, la 
                    mejora de funcionalidades existentes y la adaptaci√≥n a nuevos 
                    requisitos o cambios en el entorno tecnol√≥gico.<br>
                    <br>
                    Actividades clave: Soporte t√©cnico, correcci√≥n de 
                    errores (mantenimiento correctivo), mejoras y nuevas 
                    funcionalidades (mantenimiento perfectivo), adaptaci√≥n a 
                    cambios (mantenimiento adaptativo).<br>
                    <br>
                    Resultados: Software actualizado y funcional, 
                    satisfacci√≥n del usuario a largo plazo.<br>
                    <br>
                    Modelos Comunes del Ciclo de Vida del Software:<br>
                    Existen diferentes modelos de SDLC, cada uno con sus propias caracter√≠sticas y 
                    casos de uso:<br>
                    <br>
                    -Modelo en Cascada (Waterfall Model): Un enfoque secuencial y 
                    lineal, donde cada fase debe completarse antes de que comience la 
                    siguiente. Es simple de entender y gestionar, pero r√≠gido y menos
                    adaptable a cambios.<br>

                    -Modelo Iterativo: El desarrollo se divide en ciclos m√°s peque√±os o 
                    "iteraciones". Cada iteraci√≥n produce una versi√≥n mejorada del software. 
                    Permite la retroalimentaci√≥n temprana y la adaptaci√≥n a cambios.<br>

                    -Modelo Espiral: Combina elementos del modelo en cascada con la iteraci√≥n 
                    y el an√°lisis de riesgos. Es adecuado para proyectos grandes y complejos 
                    con riesgos significativos.<br>

                    -Modelo V: Una extensi√≥n del modelo en cascada que enfatiza la verificaci√≥n 
                    y validaci√≥n en cada etapa del desarrollo, con fases de prueba paralelas a 
                    cada fase de desarrollo.<br>

                    -Modelos √Ågiles (Scrum, Kanban): Un enfoque flexible e iterativo que 
                    prioriza la entrega de valor constante, la colaboraci√≥n con el cliente 
                    y la adaptaci√≥n al cambio. Se enfocan en ciclos cortos (sprints) y 
                    retroalimentaci√≥n frecuente.<br>
                </p>
            </div>
            <button id="btl">Leer Mas</button>
        </article>
        <script src="JavaScript/see4.js"></script>
        <article id="esf">
            <h2>I. Principios</h2>
            <div id="txf">
                <p>Los principios son las verdades fundamentales que gu√≠an las decisiones y 
                    acciones en el proceso de desarrollo de software. No son reglas estrictas, 
                    sino directrices que promueven la calidad, la eficiencia y la adaptabilidad. 
                    Algunos de los m√°s importantes incluyen:<br>
                    <br>
                    -Satisfacci√≥n del cliente: El objetivo principal es entregar software que satisfaga 
                    las necesidades y expectativas del cliente.<br>
                    <br>
                    -Entrega temprana y continua: Es mejor entregar software funcional con frecuencia, 
                    en lugar de esperar una entrega final masiva. Esto permite la retroalimentaci√≥n 
                    temprana y la adaptaci√≥n.<br>
                    <br>
                    -Adaptaci√≥n al cambio: Los requisitos cambian inevitablemente. El proceso de 
                    desarrollo debe ser lo suficientemente flexible como para acomodar estos cambios.<br>
                    <br>
                    -Colaboraci√≥n: La comunicaci√≥n y colaboraci√≥n constante entre el equipo de 
                    desarrollo, los clientes y otros stakeholders es vital.<br>
                    <br>
                    -Simplicidad: Mantener el dise√±o y el c√≥digo lo m√°s simple posible para 
                    facilitar la comprensi√≥n, el mantenimiento y la evoluci√≥n.<br>
                    <br>
                    -Calidad integrada: La calidad no es algo que se a√±ade al final, sino que 
                    se incorpora en cada etapa del proceso.<br>
                    <br>
                    -Auto-organizaci√≥n y empoderamiento del equipo: Los equipos de desarrollo 
                    funcionan mejor cuando son aut√≥nomos y pueden tomar sus propias decisiones 
                    sobre c√≥mo realizar el trabajo.<br>
                    <br>
                    -Reflexi√≥n y mejora continua: El equipo debe reflexionar regularmente 
                    sobre c√≥mo ser m√°s efectivo y ajustar su comportamiento en consecuencia.<br>
                    <br>
                </p>
            </div>
            <button id="btf">Leer Mas</button>
        </article>
        <script src="JavaScript/see5.js"></script>
        <article id="esk">
            <h2>II. Modelos del Ciclo de Vida del Software (SDLC)</h2>
            <div id="txk">
                <p>Los modelos del SDLC son marcos de trabajo que definen 
                    la secuencia de fases y actividades en el desarrollo de software. 
                    Proporcionan una estructura y un enfoque sistem√°tico. 
                    Los m√°s comunes incluyen:<br>
                    <br>
                    <stronger> a. Modelo en Cascada (Waterfall):<br>
                    <br>
                    Caracter√≠sticas: Secuencial, lineal y r√≠gido. Cada fase (requisitos, 
                    dise√±o, implementaci√≥n, pruebas, despliegue, mantenimiento) debe 
                    completarse antes de pasar a la siguiente.<br>

                    Ventajas: F√°cil de entender y gestionar, ideal para proyectos con 
                    requisitos muy estables.<br>

                    Desventajas: Poca flexibilidad ante cambios, los errores se 
                    detectan tarde, no es adecuado para proyectos complejos o con requisitos cambiantes.<br>
                    <br>
                    <stronger> b. Modelo Iterativo e Incremental:<br>
                    <br>
                    Caracter√≠sticas: El software se construye en peque√±as iteraciones, 
                    cada una a√±adiendo nuevas funcionalidades o mejoras. Cada iteraci√≥n 
                    produce una versi√≥n funcional del software.<br>

                    Ventajas: Permite la retroalimentaci√≥n temprana del cliente, mayor 
                    flexibilidad, los riesgos se manejan de forma progresiva.<br>

                    Desventajas: Puede ser dif√≠cil definir el alcance completo al inicio, 
                    requiere una buena gesti√≥n.<br>
                    <br>
                    <stronger> c. Modelo Espiral:<br>
                    <br>
                    Caracter√≠sticas: Combina elementos del modelo en cascada con la iteraci√≥n y 
                    el an√°lisis de riesgos. Cada "vuelta" en la espiral representa una fase del 
                    ciclo de vida, con un enfoque principal en la gesti√≥n de riesgos.<br>

                    Ventajas: Adecuado para proyectos grandes, complejos y de alto riesgo; 
                    permite la evaluaci√≥n y mitigaci√≥n continua de riesgos.<br>

                    Desventajas: M√°s complejo de gestionar, requiere experiencia en an√°lisis de riesgos.<br>
                    <br>
                    <stronger> d. Modelo de Prototipos:<br>
                    <br>
                    Caracter√≠sticas: Se crea un prototipo inicial (una versi√≥n simplificada y no 
                    funcional completa) para obtener retroalimentaci√≥n del cliente r√°pidamente, que 
                    luego se refina o se descarta para construir el sistema final.<br>

                    Ventajas: Clarifica los requisitos, reduce la ambig√ºedad, involucra al usuario 
                    temprano.<br>

                    Desventajas: El prototipo puede ser interpretado como el producto final, puede 
                    llevar a una implementaci√≥n deficiente si el prototipo se convierte en el sistema 
                    final sin una refactorizaci√≥n adecuada.<br>
                    <br>
                    <stronger> e. Desarrollo R√°pido de Aplicaciones (RAD - Rapid Application Development):<br>
                    <br>
                    Caracter√≠sticas: Se enfoca en el desarrollo r√°pido de prototipos y la entrega 
                    incremental, utilizando herramientas de desarrollo r√°pido y la reutilizaci√≥n de 
                    componentes.<br>

                    Ventajas: Ciclos de desarrollo cortos, alta participaci√≥n del usuario.<br>

                    Desventajas: Requiere equipos peque√±os y altamente capacitados, puede llevar a 
                    un dise√±o deficiente si no se gestiona bien.<br>
                </p>
            </div>
            <button id="btk">Leer Mas</button>
        </article>
        <script src="JavaScript/see6.js"></script>
        <article id="esv">
            <h2>III. Metodolog√≠as de Desarrollo de Software</h2>
            <div id="txv">
                <p>Las metodolog√≠as son enfoques sistem√°ticos y estructurados que gu√≠an todo el proceso de desarrollo, desde la planificaci√≥n hasta el mantenimiento. Pueden incorporar uno o varios modelos de SDLC. Se dividen principalmente en Tradicionales/Cl√°sicas y √Ågiles.

                    A. Metodolog√≠as Tradicionales/Cl√°sicas:<br>
                    Generalmente siguen un enfoque m√°s secuencial y planificado.<br>
                    <br>
                    -Cascada: (Descrita en Modelos de SDLC).

                    -Prototipos: (Descrita en Modelos de SDLC).

                    -Espiral: (Descrita en Modelos de SDLC).

                    -Incremental: (Descrita en Modelos de SDLC).

                    B. Metodolog√≠as √Ågiles:<br>
                    Se basan en un conjunto de valores y principios del Manifiesto √Ågil, 
                    enfatizando la flexibilidad, la colaboraci√≥n, la entrega frecuente de software 
                    funcional y la adaptaci√≥n al cambio.<br>
                    <br>
                    -Scrum:<br>
                    <br>
                    Caracter√≠sticas: Marco de trabajo iterativo e incremental basado en "sprints" 
                    (ciclos de trabajo cortos, generalmente de 1 a 4 semanas). Utiliza roles 
                    definidos (Product Owner, Scrum Master, Equipo de Desarrollo) y artefactos 
                    (Backlog del producto, Backlog del sprint, Incremento).<br>

                    Ventajas: Alta adaptabilidad, entrega continua de valor, mejora la colaboraci√≥n.<br>

                    Desventajas: Requiere equipos auto-organizados y disciplinados, puede ser dif√≠cil 
                    para organizaciones con jerarqu√≠as r√≠gidas.<br>
                    <br>
                    -Kanban:<br>
                    <br>
                    Caracter√≠sticas: Se enfoca en la visualizaci√≥n del flujo de trabajo, 
                    la limitaci√≥n del trabajo en progreso (WIP) y la mejora continua. 
                    Utiliza tableros visuales (Kanban boards) para representar el estado de las tareas.<br>

                    Ventajas: Flexibilidad para gestionar prioridades cambiantes, 
                    mejora la eficiencia del flujo de trabajo, reduce los cuellos de botella.<br>

                    Desventajas: Menos estructurado que Scrum, puede ser dif√≠cil para equipos 
                    que necesitan m√°s gu√≠a.<br>
                    <br>
                    -Programaci√≥n Extrema (XP - eXtreme Programming):<br>
                    <br>
                    Caracter√≠sticas: Se centra en pr√°cticas de ingenier√≠a de software 
                    para producir software de alta calidad r√°pidamente. Incluye pr√°cticas 
                    como desarrollo guiado por pruebas (TDD), programaci√≥n en parejas, 
                    refactorizaci√≥n continua, integraci√≥n continua y reuniones diarias.<br>

                    Ventajas: Mejora la calidad del c√≥digo, reduce los defectos, fomenta la comunicaci√≥n.<br>

                    Desventajas: Puede ser exigente para el equipo, requiere mucha disciplina.<br>
                    <br>
                    -Lean Software Development:<br>
                    <br>
                    Caracter√≠sticas: Se basa en los principios de producci√≥n "Lean" de Toyota. 
                    Se enfoca en eliminar el desperdicio, construir calidad, crear conocimiento, 
                    posponer el compromiso, entregar r√°pido, respetar a las personas y optimizar 
                    el todo.<br>

                    Ventajas: Eficiencia, reducci√≥n de desperdicio, enfoque en el valor para el cliente.<br>

                    Desventajas: Requiere una mentalidad de mejora continua, puede ser dif√≠cil de 
                    implementar en organizaciones grandes.<br>
                </p>
            </div>
            <button id="btv">Leer Mas</button>
        </article>
        <script src="JavaScript/see7.js"></script>
        <article id="esg">
            <h2>IV. M√©todos y T√©cnicas en el Proceso de Desarrollo de Software</h2>
            <div id="txg">
                <p>Los m√©todos y t√©cnicas son las formas espec√≠ficas de realizar las 
                    actividades dentro de las fases y metodolog√≠as.<br>
                    <br>
                    M√©todos de Recopilaci√≥n de Requisitos:<br>
                    <br>
                    Entrevistas, encuestas, talleres (JAD/RAD), prototipado, casos de uso, 
                    historias de usuario.<br>
                    <br>
                    M√©todos de Dise√±o:<br>
                    <br>
                    Dise√±o orientado a objetos (UML - Unified Modeling Language), 
                    dise√±o de bases de datos (modelado entidad-relaci√≥n), patrones de dise√±o.<br>
                    <br>
                    M√©todos de Codificaci√≥n:<br>
                    <br>
                    Programaci√≥n en parejas, TDD (Desarrollo Guiado por Pruebas), refactorizaci√≥n.<br>
                    <br>
                    M√©todos de Pruebas:<br>
                    <br>
                    Pruebas unitarias, pruebas de integraci√≥n, pruebas de sistema, 
                    pruebas de aceptaci√≥n, pruebas de regresi√≥n, pruebas de rendimiento, 
                    pruebas de seguridad, pruebas de usabilidad.<br>
                    <br>
                    T√©cnicas de Gesti√≥n de Proyectos:<br>
                    <br>
                    Estimaci√≥n de esfuerzo (Puntos de Funci√≥n, Puntos de Historia), 
                    gesti√≥n de riesgos, gesti√≥n de configuraci√≥n, planificaci√≥n de sprints.<br>
                </p>
            </div>
            <button id="btg">Leer Mas</button>
        </article>
        <script src="JavaScript/see8.js"></script>
        <article id="esy">
            <h2>V. Actividades Comunes en el Proceso de Desarrollo de Software</h2>
            <div id="txy">
                <p>Las actividades son las tareas concretas que se realizan en cada fase del SDLC...<br>
                    <br>
                    An√°lisis y Dise√±o:<br>
                    <br>
                    Identificaci√≥n de stakeholders, elicitaci√≥n de requisitos, modelado de procesos, 
                    creaci√≥n de diagramas de casos de uso, dise√±o de la arquitectura, dise√±o de 
                    interfaces de usuario, dise√±o de la base de datos.<br>
                    <br>
                    Implementaci√≥n:<br>
                    <br>
                    Escritura de c√≥digo, desarrollo de pruebas unitarias, integraci√≥n de m√≥dulos, 
                    gesti√≥n de versiones.<br>
                    <br>
                    Pruebas:<br>
                    <br>
                    Preparaci√≥n de casos de prueba, ejecuci√≥n de pruebas, reporte y seguimiento 
                    de defectos, automatizaci√≥n de pruebas.<br>
                    <br>
                    Despliegue:<br>
                    <br>
                    Instalaci√≥n y configuraci√≥n del software, migraci√≥n de datos, 
                    capacitaci√≥n a usuarios, lanzamiento.<br>
                    <br>
                    Mantenimiento:<br>
                    <br>
                    Correcci√≥n de bugs, implementaci√≥n de mejoras, actualizaciones de 
                    seguridad, monitoreo del rendimiento.<br>
                    <br>
                    Gesti√≥n del Proyecto:<br>
                    <br>
                    Planificaci√≥n, seguimiento del progreso, gesti√≥n de riesgos, gesti√≥n de la 
                    comunicaci√≥n, gesti√≥n del alcance.<br>
                    </p>
            </div>
            <button id="bty">Leer Mas</button>
        </article>
        <script src="JavaScript/see9.js"></script>
        <article id="es1">
            <h2>VI. Herramientas en el Proceso de Desarrollo de Software</h2>
            <div id="tx1">
                <p>Las herramientas de software ayudan a automatizar, gestionar y facilitar las 
                    diferentes actividades del proceso.<br>
                    <br>
                    Herramientas de Gesti√≥n de Proyectos y Tareas:<br>

                    Jira, Trello, Asana, Monday.com, Azure DevOps.<br>
                    <br>
                    Herramientas de Control de Versiones:<br>

                    Git (GitHub, GitLab, Bitbucket), SVN.<br>
                    <br>
                    Entornos de Desarrollo Integrado (IDE):<br>

                    Visual Studio Code, IntelliJ IDEA, Eclipse, Xcode.<br>
                    <br>
                    Herramientas de Pruebas:<br>

                    Selenium (automatizaci√≥n web), JUnit/NUnit/Pytest (pruebas unitarias), Postman (pruebas de API), JMeter (pruebas de rendimiento).
                    <br><br>
                    Herramientas de Integraci√≥n Continua/Entrega Continua (CI/CD):<br>

                    Jenkins, GitLab CI/CD, GitHub Actions, CircleCI.<br>
                    <br>
                    Herramientas de Modelado:<br>

                    Lucidchart, Draw.io, Enterprise Architect (para diagramas UML).<br>
                    <br>
                    Herramientas de Gesti√≥n de Requisitos:<br>

                    Jira, Confluence, IBM DOORS.<br>
                    <br>
                    Herramientas de Gesti√≥n de Bases de Datos:<br>

                    DBeaver, SQL Developer, MySQL Workbench, pgAdmin.<br>
                    <br>
                    Frameworks y Librer√≠as de Desarrollo:<br>

                    React, Angular, Vue.js (frontend), Node.js, Spring Boot, Django, Ruby on Rails (backend).
                    <br>
                </p>
            </div>
            <button id="bt1">Leer Mas</button>
        </article>
        <script src="JavaScript/see10.js"></script>
         <article id="es8">
            <h2>Seleccion del Modelo Apropiado segun las caracteristicas de los Proyectos de Software</h2>
            <div id="tx8">
                <p>La selecci√≥n del modelo de ciclo de vida del software (SDLC) m√°s adecuado es una decisi√≥n crucial que puede determinar el √©xito o fracaso de un proyecto. No existe una soluci√≥n √∫nica que sirva para todos los casos; la elecci√≥n depende de las caracter√≠sticas espec√≠ficas del proyecto.
                    <br>
                        1. Modelo en Cascada (Waterfall)
                        Cu√°ndo usarlo:<br>
                        <br>
                        Requisitos muy claros, estables y bien documentados: Proyectos donde 
                        los requisitos no cambiar√°n.<br>
                        <br>
                        Proyectos peque√±os y de bajo riesgo: Donde la posibilidad de fallos es m√≠nima.<br>
                        <br>
                        Tecnolog√≠a y herramientas estables: Cuando la tecnolog√≠a a usar es 
                        conocida y no se esperan grandes cambios.<br>
                        <br>
                        Equipos grandes con roles definidos: Permite una gesti√≥n m√°s 
                        tradicional y jer√°rquicas. Entregables bien definidos en cada fase.<br>

                        Ejemplos: Sistemas operativos embebidos para hardware espec√≠fico, software para dispositivos m√©dicos con regulaciones estrictas, proyectos con contratos fijos y especificaciones detalladas.
                        <br><br>
                        2. Modelos √Ågiles (Scrum, Kanban, XP)
                        Cu√°ndo usarlo:<br>
                        <br>
                        Requisitos cambiantes o poco claros: Cuando no se puede definir todo al inicio 
                        o se espera que los requisitos evolucionen.<br>
                        <br>
                        Alta necesidad de feedback del cliente: Si el cliente quiere estar 
                        involucrado de cerca y dar retroalimentaci√≥n constante.<br>
                        <br>
                        Proyectos complejos e innovadores: Donde la experimentaci√≥n y el aprendizaje 
                        son clave.<br>
                        <br>
                        Entrega temprana y frecuente de valor: Cuando se necesita un producto 
                        funcional en iteraciones cortas.<br>
                        <br>
                        Equipos peque√±os, autoorganizados y colaborativos: Fomenta la 
                        comunicaci√≥n constante y la toma de decisiones descentralizada.<br>
                        <br>
                        Ejemplos: Desarrollo de aplicaciones m√≥viles, plataformas web din√°micas, startups con productos m√≠nimos viables (MVP), proyectos en mercados de r√°pida evoluci√≥n.
                        <br><br>
                        3. Modelo Espiral
                        Cu√°ndo usarlo:<br>
                        <br>
                        Proyectos grandes, complejos y de alto riesgo: Cuando la mitigaci√≥n de 
                        riesgos es la prioridad principal.<br>
                        <br>
                        Requisitos que evolucionan con el tiempo: Permite una definici√≥n 
                        incremental de los requisitos.<br>
                        <br>
                        Incertidumbre en la tecnolog√≠a o el mercado: Ideal para 
                        proyectos de investigaci√≥n y desarrollo. Alta necesidad de an√°lisis de riesgos continuo.
                        <br><br>
                        Ejemplos: Grandes sistemas empresariales, software de defensa, proyectos de inteligencia artificial, sistemas cr√≠ticos donde la evaluaci√≥n de riesgos es fundamental en cada etapa.

                        4. Modelo de Prototipos
                        Cu√°ndo usarlo:<br>
                        <br>
                        Requisitos ambiguos o poco claros: Cuando el usuario no sabe exactamente 
                        lo que quiere o necesita ver una versi√≥n funcional para aclararlo.<br>
                        <br>
                        Interfaz de usuario (UI) y experiencia de usuario (UX) cr√≠ticas: 
                        Para validar la usabilidad y el dise√±o con los usuarios finales.<br>
                        <br>
                        Alto riesgo de aceptaci√≥n del usuario: Si la adopci√≥n del sistema 
                        por parte del usuario es incierta. Necesidad de feedback r√°pido sobre el dise√±o.

                        Ejemplos: Aplicaciones con interfaces de usuario innovadoras, sistemas interactivos, software donde la usabilidad es un factor clave de √©xito.
                        </p>
            </div>
            <button id="bt8">Leer Mas</button>
        </article>
        <script src="JavaScript/see12.js"></script>
    </body>
</html>
